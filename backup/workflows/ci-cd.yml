name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  security-events: write
  actions: read
  packages: write
  pull-requests: write
  issues: write

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: oddiya
  ECS_SERVICE: oddiya-dev
  ECS_CLUSTER: oddiya-dev
  CONTAINER_NAME: oddiya-app
  
jobs:
  # ==========================================
  # Code Quality & Security Checks
  # ==========================================
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          
      - name: Cache Gradle dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
            
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        
      - name: Code Quality Check
        run: ./gradlew check --no-daemon
        
      - name: Security Scan
        run: |
          echo "Security scan completed - manual review recommended"
          echo "Consider running: docker run --rm -v \$PWD:/workspace aquasec/trivy fs /workspace"

  # ==========================================
  # Build & Test
  # ==========================================
  build-test:
    runs-on: ubuntu-latest
    needs: code-quality
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: oddiya
          POSTGRES_PASSWORD: oddiya123
          POSTGRES_DB: oddiya_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
          
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          
      - name: Cache Gradle dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
            
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        
      - name: Build Application
        run: ./gradlew clean build --no-daemon
        
      - name: Run Tests
        run: ./gradlew test --no-daemon
        env:
          SPRING_PROFILES_ACTIVE: test
          
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: build/test-results/test/*.xml
          retention-days: 1
          
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: build/libs/*.jar
          retention-days: 1

  # ==========================================
  # Build Docker Image
  # ==========================================
  build-docker:
    runs-on: ubuntu-latest
    needs: build-test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') && github.repository == 'swm16-wREck/Oddiya-Backend'
    
    outputs:
      image-tag: ${{ steps.image.outputs.tag }}
      
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: build/libs
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Build, tag, and push image to Amazon ECR
        id: image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  # ==========================================
  # Deploy to Development
  # ==========================================
  deploy-dev:
    runs-on: ubuntu-latest
    needs: build-docker
    if: github.ref == 'refs/heads/develop'
    environment:
      name: development
      url: https://dev.oddiya.com
      
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Pre-deployment validation
        run: |
          echo "üîç Pre-deployment validation for development..."
          
          # Check if cluster and service exist
          if ! aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }}-dev --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå ECS cluster not found, deployment may fail"
            exit 1
          fi
          
          if ! aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }}-dev --services ${{ env.ECS_SERVICE }}-dev --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå ECS service not found, deployment may fail"
            exit 1
          fi
          
          echo "‚úÖ Pre-deployment validation passed"
          
      - name: Deploy to ECS (Development) with resilient monitoring
        id: deploy-dev
        run: |
          echo "üöÄ Starting resilient deployment to development..."
          
          # Store current task definition for rollback
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }}-dev \
            --services ${{ env.ECS_SERVICE }}-dev \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' --output text)
          echo "current_task_def=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
          
          # Initiate deployment
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }}-dev \
            --service ${{ env.ECS_SERVICE }}-dev \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Deployment initiated"
          
          # Enhanced monitoring with timeout
          TIMEOUT_SECONDS=1200  # 20 minutes
          ELAPSED=0
          DEPLOYMENT_START=$(date +%s)
          
          while [ $ELAPSED -lt $TIMEOUT_SECONDS ]; do
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }}-dev \
              --services ${{ env.ECS_SERVICE }}-dev \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].deployments[?status==`PRIMARY`] | [0].rolloutState' \
              --output text)
            
            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }}-dev \
              --services ${{ env.ECS_SERVICE }}-dev \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].runningCount' --output text)
            
            DESIRED_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }}-dev \
              --services ${{ env.ECS_SERVICE }}-dev \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].desiredCount' --output text)
            
            echo "üîÑ Status: $DEPLOYMENT_STATUS | Running: $RUNNING_COUNT/$DESIRED_COUNT | Elapsed: ${ELAPSED}s"
            
            if [ "$DEPLOYMENT_STATUS" = "COMPLETED" ]; then
              echo "‚úÖ Development deployment completed successfully!"
              echo "deployment_result=success" >> $GITHUB_OUTPUT
              break
            elif [ "$DEPLOYMENT_STATUS" = "FAILED" ]; then
              echo "‚ùå Development deployment failed!"
              echo "deployment_result=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            sleep 30
            ELAPSED=$(($(date +%s) - $DEPLOYMENT_START))
          done
          
          if [ $ELAPSED -ge $TIMEOUT_SECONDS ]; then
            echo "‚è∞ Deployment timed out after $TIMEOUT_SECONDS seconds"
            echo "deployment_result=timeout" >> $GITHUB_OUTPUT
            exit 1
          fi
            
      - name: Post-deployment health check (Development)
        if: steps.deploy-dev.outputs.deployment_result == 'success'
        continue-on-error: true
        run: |
          echo "üè• Running post-deployment health check..."
          
          # Basic service health check
          SERVICE_HEALTHY=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }}-dev \
            --services ${{ env.ECS_SERVICE }}-dev \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount}' \
            --output json)
          
          echo "üìä Service health status:"
          echo "$SERVICE_HEALTHY" | jq .
          
          STATUS=$(echo "$SERVICE_HEALTHY" | jq -r '.Status')
          RUNNING=$(echo "$SERVICE_HEALTHY" | jq -r '.RunningCount')
          DESIRED=$(echo "$SERVICE_HEALTHY" | jq -r '.DesiredCount')
          
          if [ "$STATUS" = "ACTIVE" ] && [ "$RUNNING" = "$DESIRED" ]; then
            echo "‚úÖ Development deployment health check passed"
          else
            echo "‚ö†Ô∏è Development deployment may have issues"
          fi
          
      - name: Rollback on failure (Development)
        if: failure() && steps.deploy-dev.outputs.current_task_def != ''
        continue-on-error: true
        run: |
          echo "üîÑ Rolling back development deployment..."
          
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }}-dev \
            --service ${{ env.ECS_SERVICE }}-dev \
            --task-definition ${{ steps.deploy-dev.outputs.current_task_def }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚ö†Ô∏è Rollback initiated for development environment"

  # ==========================================
  # Deploy to Production
  # ==========================================
  deploy-prod:
    runs-on: ubuntu-latest
    needs: build-docker
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://oddiya.com
      
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Pre-deployment validation (Production)
        run: |
          echo "üîç Pre-deployment validation for production..."
          
          # Check if cluster and service exist
          if ! aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå Production ECS cluster not found, deployment will fail"
            exit 1
          fi
          
          if ! aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå Production ECS service not found, deployment will fail"
            exit 1
          fi
          
          # Production-specific checks
          echo "üîí Verifying production readiness..."
          
          # Check current service health before deploying
          CURRENT_HEALTH=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount}' \
            --output json)
          
          CURRENT_STATUS=$(echo "$CURRENT_HEALTH" | jq -r '.Status')
          if [ "$CURRENT_STATUS" != "ACTIVE" ]; then
            echo "‚ö†Ô∏è Current production service status is $CURRENT_STATUS, proceeding with caution"
          else
            echo "‚úÖ Production service currently healthy"
          fi
          
      - name: Deploy to ECS (Production) with enhanced monitoring
        id: deploy-prod
        run: |
          echo "üöÄ Starting production deployment with enhanced monitoring..."
          
          # Store current task definition for rollback
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' --output text)
          echo "current_task_def=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
          echo "üìù Stored rollback task definition: $CURRENT_TASK_DEF"
          
          # Initiate deployment
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Production deployment initiated at $(date)"
          
          # Enhanced monitoring with extended timeout for production
          TIMEOUT_SECONDS=1800  # 30 minutes for production
          ELAPSED=0
          DEPLOYMENT_START=$(date +%s)
          LAST_STATUS=""
          
          while [ $ELAPSED -lt $TIMEOUT_SECONDS ]; do
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].deployments[?status==`PRIMARY`] | [0].rolloutState' \
              --output text)
            
            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].runningCount' --output text)
            
            DESIRED_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].desiredCount' --output text)
            
            # Only log status changes to reduce noise
            CURRENT_STATUS="$DEPLOYMENT_STATUS-$RUNNING_COUNT/$DESIRED_COUNT"
            if [ "$CURRENT_STATUS" != "$LAST_STATUS" ]; then
              echo "üîÑ Production deployment - Status: $DEPLOYMENT_STATUS | Tasks: $RUNNING_COUNT/$DESIRED_COUNT | Elapsed: ${ELAPSED}s | $(date)"
              LAST_STATUS="$CURRENT_STATUS"
            fi
            
            if [ "$DEPLOYMENT_STATUS" = "COMPLETED" ]; then
              echo "‚úÖ Production deployment completed successfully at $(date)!"
              echo "deployment_result=success" >> $GITHUB_OUTPUT
              break
            elif [ "$DEPLOYMENT_STATUS" = "FAILED" ]; then
              echo "‚ùå Production deployment failed at $(date)!"
              
              # Get failure details
              echo "üìã Recent service events:"
              aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }} \
                --services ${{ env.ECS_SERVICE }} \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].events[:5].[createdAt,message]' \
                --output table
              
              echo "deployment_result=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            sleep 30
            ELAPSED=$(($(date +%s) - $DEPLOYMENT_START))
          done
          
          if [ $ELAPSED -ge $TIMEOUT_SECONDS ]; then
            echo "‚è∞ Production deployment timed out after $TIMEOUT_SECONDS seconds"
            echo "üîç Current deployment status: $DEPLOYMENT_STATUS"
            echo "deployment_result=timeout" >> $GITHUB_OUTPUT
            exit 1
          fi
            
      - name: Post-deployment health check (Production)
        if: steps.deploy-prod.outputs.deployment_result == 'success'
        run: |
          echo "üè• Running comprehensive production health check..."
          
          # Comprehensive service health check
          SERVICE_HEALTH=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output json)
          
          echo "üìä Final production service health:"
          echo "$SERVICE_HEALTH" | jq .
          
          # Verify all tasks are healthy
          STATUS=$(echo "$SERVICE_HEALTH" | jq -r '.Status')
          RUNNING=$(echo "$SERVICE_HEALTH" | jq -r '.RunningCount')
          DESIRED=$(echo "$SERVICE_HEALTH" | jq -r '.DesiredCount')
          
          if [ "$STATUS" = "ACTIVE" ] && [ "$RUNNING" = "$DESIRED" ]; then
            echo "‚úÖ Production deployment health check passed"
            echo "üéâ Production is ready to serve traffic!"
          else
            echo "‚ö†Ô∏è Production deployment may have issues - manual verification recommended"
            exit 1
          fi
          
          # Additional health checks if load balancer is available
          echo "üîç Checking load balancer target health..."
          LOAD_BALANCER=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)
          
          if [ "$LOAD_BALANCER" != "None" ] && [ "$LOAD_BALANCER" != "null" ]; then
            aws elbv2 describe-target-health \
              --target-group-arn "$LOAD_BALANCER" \
              --region ${{ env.AWS_REGION }} \
              --query 'TargetHealthDescriptions[].[Target.Id,TargetHealth.State,TargetHealth.Description]' \
              --output table || echo "‚ö†Ô∏è Could not verify target health"
          else
            echo "‚ÑπÔ∏è No load balancer configured"
          fi
          
      - name: Rollback on failure (Production)
        if: failure() && steps.deploy-prod.outputs.current_task_def != ''
        run: |
          echo "üö® PRODUCTION DEPLOYMENT FAILED - INITIATING EMERGENCY ROLLBACK"
          
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.deploy-prod.outputs.current_task_def }} \
            --region ${{ env.AWS_REGION }}
          
          echo "üîÑ Production rollback initiated to: ${{ steps.deploy-prod.outputs.current_task_def }}"
          
          # Wait for rollback to stabilize (with timeout)
          echo "‚è≥ Waiting for rollback to complete..."
          timeout 900 aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} && echo "‚úÖ Rollback completed" || echo "‚ö†Ô∏è Rollback may still be in progress"
          
          # Verify rollback
          ROLLBACK_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount}' \
            --output json)
          
          echo "üìä Rollback status:"
          echo "$ROLLBACK_STATUS" | jq .
          
      - name: Trigger post-deployment monitoring
        if: success()
        continue-on-error: true
        uses: ./.github/workflows/deployment-monitoring.yml
        with:
          environment: production
          monitoring_duration: "20"
          
      - name: Notify Deployment (Discord)
        if: always()
        continue-on-error: true
        run: |
          # Enhanced notification with deployment details
          if [ "${{ job.status }}" = "success" ]; then
            COLOR="3066993"
            TITLE="‚úÖ Production Deployment Successful"
            DESCRIPTION="Production deployment completed successfully with enhanced monitoring"
          else
            COLOR="15158332"
            TITLE="‚ùå Production Deployment Failed"
            DESCRIPTION="Production deployment failed - rollback may have been initiated"
          fi
          
          # Get final deployment info
          DEPLOYMENT_INFO="Not available"
          if [ "${{ steps.deploy-prod.outputs.deployment_result }}" != "" ]; then
            DEPLOYMENT_INFO="Result: ${{ steps.deploy-prod.outputs.deployment_result }}"
          fi
          
          WEBHOOK="${{ secrets.DISCORD_WEBHOOK }}"
          if [ -z "$WEBHOOK" ]; then
            echo "Discord notification skipped - DISCORD_WEBHOOK secret not configured"
          else
            curl -H "Content-Type: application/json" \
              -X POST \
              -d "{
                \"embeds\": [{
                  \"title\": \"$TITLE\",
                  \"description\": \"$DESCRIPTION\",
                  \"color\": $COLOR,
                  \"fields\": [
                    {\"name\": \"Repository\", \"value\": \"${{ github.repository }}\", \"inline\": true},
                    {\"name\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"inline\": true},
                    {\"name\": \"Commit\", \"value\": \"${{ github.sha }}\", \"inline\": false},
                    {\"name\": \"Deployment Info\", \"value\": \"$DEPLOYMENT_INFO\", \"inline\": false},
                    {\"name\": \"Monitoring\", \"value\": \"Post-deployment monitoring ${{ success() && 'initiated' || 'skipped' }}\", \"inline\": true}
                  ],
                  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
                }]
              }" \
              "$WEBHOOK" || echo "Discord notification failed"
          fi

  # ==========================================
  # Infrastructure as Code (Optional)
  # ==========================================
  terraform:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Add timeout to prevent hanging
    # Temporarily disabled - infrastructure already exists
    # Re-enable after importing existing resources into Terraform state
    if: false  # github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Terraform Init
        run: |
          cd terraform/simple-deploy
          terraform init
          
      - name: Terraform Plan
        run: |
          cd terraform/simple-deploy
          # Since we're using DynamoDB, provide a dummy password for RDS (not used)
          terraform plan -var="db_password=dummy-password-not-used-with-dynamodb" -out=tfplan
          
      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        run: |
          cd terraform/simple-deploy
          terraform apply -auto-approve tfplan