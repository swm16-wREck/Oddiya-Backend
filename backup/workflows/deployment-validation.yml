name: Deployment Validation & Troubleshooting

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to validate'
        required: true
        default: 'development'
        type: choice
        options:
        - development
        - production
      validation_type:
        description: 'Type of validation to perform'
        required: true
        default: 'health-check'
        type: choice
        options:
        - health-check
        - full-validation
        - troubleshoot
        - performance-test
      fix_issues:
        description: 'Attempt to fix detected issues automatically'
        required: false
        default: false
        type: boolean
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      validation_type:
        required: false
        type: string
        default: 'health-check'

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: oddiya
  
jobs:
  validation:
    name: Deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure environment variables
        run: |
          if [ "${{ inputs.environment }}" = "production" ]; then
            echo "ECS_CLUSTER=oddiya-prod" >> $GITHUB_ENV
            echo "ECS_SERVICE=oddiya-prod" >> $GITHUB_ENV
            echo "HEALTH_URL=https://oddiya.com" >> $GITHUB_ENV
          else
            echo "ECS_CLUSTER=oddiya-dev" >> $GITHUB_ENV
            echo "ECS_SERVICE=oddiya-dev" >> $GITHUB_ENV  
            echo "HEALTH_URL=https://dev.oddiya.com" >> $GITHUB_ENV
          fi
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Install validation dependencies
        run: |
          # Install additional tools for validation
          sudo apt-get update
          sudo apt-get install -y curl jq bc dnsutils netcat-openbsd
          
          # Install AWS CLI plugins if needed
          pip install boto3 requests
          
      - name: Basic Health Check
        id: health-check
        run: |
          echo "=== BASIC HEALTH CHECK ==="
          
          # Check ECS cluster status
          echo "üîç Checking ECS cluster health..."
          CLUSTER_STATUS=$(aws ecs describe-clusters \
            --clusters ${{ env.ECS_CLUSTER }} \
            --region ${{ env.AWS_REGION }} \
            --query 'clusters[0].status' --output text)
            
          if [ "$CLUSTER_STATUS" != "ACTIVE" ]; then
            echo "‚ùå Cluster status: $CLUSTER_STATUS"
            echo "health_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "‚úÖ Cluster is ACTIVE"
          
          # Check ECS service health
          echo "üîç Checking ECS service health..."
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Deployments:length(deployments)}' \
            --output json)
            
          SERVICE_STATUS=$(echo "$SERVICE_INFO" | jq -r '.Status')
          RUNNING_COUNT=$(echo "$SERVICE_INFO" | jq -r '.Running')
          DESIRED_COUNT=$(echo "$SERVICE_INFO" | jq -r '.Desired')
          DEPLOYMENT_COUNT=$(echo "$SERVICE_INFO" | jq -r '.Deployments')
          
          echo "üìä Service Status: $SERVICE_STATUS"
          echo "üìä Tasks Running: $RUNNING_COUNT/$DESIRED_COUNT"
          echo "üìä Active Deployments: $DEPLOYMENT_COUNT"
          
          if [ "$SERVICE_STATUS" != "ACTIVE" ]; then
            echo "‚ùå Service is not ACTIVE"
            echo "health_status=degraded" >> $GITHUB_OUTPUT
          elif [ "$RUNNING_COUNT" != "$DESIRED_COUNT" ]; then
            echo "‚ö†Ô∏è Service not at desired capacity"
            echo "health_status=degraded" >> $GITHUB_OUTPUT
          elif [ "$DEPLOYMENT_COUNT" -gt 1 ]; then
            echo "‚ö†Ô∏è Multiple deployments in progress"
            echo "health_status=deploying" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Service is healthy"
            echo "health_status=healthy" >> $GITHUB_OUTPUT
          fi
          
      - name: Application Health Check
        if: steps.health-check.outputs.health_status != 'failed'
        id: app-health
        continue-on-error: true
        run: |
          echo "=== APPLICATION HEALTH CHECK ==="
          
          # Get load balancer DNS name
          ALB_DNS=""
          ALB_ARN=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)
          
          if [ "$ALB_ARN" != "None" ] && [ "$ALB_ARN" != "null" ]; then
            # Extract load balancer ARN and get DNS name
            LB_ARN=$(aws elbv2 describe-target-groups \
              --target-group-arns "$ALB_ARN" \
              --region ${{ env.AWS_REGION }} \
              --query 'TargetGroups[0].LoadBalancerArns[0]' \
              --output text)
              
            if [ "$LB_ARN" != "None" ]; then
              ALB_DNS=$(aws elbv2 describe-load-balancers \
                --load-balancer-arns "$LB_ARN" \
                --region ${{ env.AWS_REGION }} \
                --query 'LoadBalancers[0].DNSName' \
                --output text)
            fi
          fi
          
          # Test application endpoints
          if [ ! -z "$ALB_DNS" ]; then
            echo "üåê Testing load balancer endpoint: $ALB_DNS"
            
            # Test health endpoint
            if curl -f -s -m 10 "http://$ALB_DNS/actuator/health" > /tmp/health_response.json; then
              echo "‚úÖ Health endpoint responding"
              cat /tmp/health_response.json | jq .
              echo "app_health=healthy" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Health endpoint not responding"
              echo "app_health=unhealthy" >> $GITHUB_OUTPUT
            fi
            
            # Test info endpoint
            if curl -f -s -m 10 "http://$ALB_DNS/actuator/info" > /tmp/info_response.json; then
              echo "‚úÖ Info endpoint responding"
              cat /tmp/info_response.json | jq .
            else
              echo "‚ö†Ô∏è Info endpoint not responding"
            fi
            
            # Basic connectivity test
            echo "üîå Testing basic connectivity..."
            if nc -z -w 5 "$ALB_DNS" 80; then
              echo "‚úÖ Port 80 accessible"
            else
              echo "‚ùå Port 80 not accessible"
            fi
            
          else
            echo "‚ö†Ô∏è No load balancer found, testing task IPs directly"
            
            # Get task IPs and test directly
            TASK_IPS=$(aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service-name ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --desired-status RUNNING \
              --query 'taskArns' --output text | \
            xargs aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --region ${{ env.AWS_REGION }} \
              --tasks | \
            jq -r '.tasks[].attachments[]?.details[]? | select(.name=="privateIPv4Address") | .value')
            
            for IP in $TASK_IPS; do
              echo "üîç Testing task IP: $IP"
              if curl -f -s -m 10 "http://$IP:8080/actuator/health"; then
                echo "‚úÖ Task $IP responding"
                echo "app_health=healthy" >> $GITHUB_OUTPUT
                break
              else
                echo "‚ùå Task $IP not responding"
              fi
            done
          fi
          
      - name: Deep Troubleshooting
        if: inputs.validation_type == 'troubleshoot' || steps.health-check.outputs.health_status == 'failed'
        run: |
          echo "=== DEEP TROUBLESHOOTING ==="
          
          # Run the existing troubleshooting script
          chmod +x scripts/check-ecs-deployment.sh
          ./scripts/check-ecs-deployment.sh
          
          # Additional troubleshooting
          echo "üîç Checking recent CloudWatch logs..."
          LOG_GROUP="/aws/ecs/${{ env.ECS_CLUSTER }}"
          
          # Get recent log events
          aws logs describe-log-groups \
            --log-group-name-prefix "$LOG_GROUP" \
            --region ${{ env.AWS_REGION }} || echo "No CloudWatch logs found"
          
          # Check for common issues
          echo "üîç Checking for common deployment issues..."
          
          # Check security groups
          SECURITY_GROUPS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration.securityGroups' \
            --output text)
          
          if [ ! -z "$SECURITY_GROUPS" ]; then
            echo "üõ°Ô∏è Security Groups: $SECURITY_GROUPS"
            for SG in $SECURITY_GROUPS; do
              aws ec2 describe-security-groups \
                --group-ids "$SG" \
                --region ${{ env.AWS_REGION }} \
                --query 'SecurityGroups[0].{GroupId:GroupId,InboundRules:IpPermissions}' || true
            done
          fi
          
          # Check subnets
          SUBNETS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration.subnets' \
            --output text)
          
          if [ ! -z "$SUBNETS" ]; then
            echo "üåê Subnets: $SUBNETS"
            for SUBNET in $SUBNETS; do
              aws ec2 describe-subnets \
                --subnet-ids "$SUBNET" \
                --region ${{ env.AWS_REGION }} \
                --query 'Subnets[0].{SubnetId:SubnetId,AvailabilityZone:AvailabilityZone,CidrBlock:CidrBlock}' || true
            done
          fi
          
      - name: Performance Testing  
        if: inputs.validation_type == 'performance-test' || inputs.validation_type == 'full-validation'
        continue-on-error: true
        run: |
          echo "=== PERFORMANCE TESTING ==="
          
          # Get load balancer endpoint
          ALB_DNS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text | \
          xargs aws elbv2 describe-target-groups \
            --target-group-arns \
            --region ${{ env.AWS_REGION }} \
            --query 'TargetGroups[0].LoadBalancerArns[0]' \
            --output text | \
          xargs aws elbv2 describe-load-balancers \
            --load-balancer-arns \
            --region ${{ env.AWS_REGION }} \
            --query 'LoadBalancers[0].DNSName' \
            --output text 2>/dev/null || echo "")
          
          if [ ! -z "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            echo "üöÄ Running performance tests against $ALB_DNS"
            
            # Simple load test
            echo "üìä Response time test..."
            for i in {1..5}; do
              RESPONSE_TIME=$(curl -w "%{time_total}" -s -o /dev/null "http://$ALB_DNS/actuator/health")
              echo "  Request $i: ${RESPONSE_TIME}s"
            done
            
            # Concurrent requests test
            echo "üìä Concurrent requests test..."
            time (
              for i in {1..10}; do
                curl -s "http://$ALB_DNS/actuator/health" > /dev/null &
              done
              wait
            )
            
          else
            echo "‚ö†Ô∏è No load balancer available for performance testing"
          fi
          
      - name: Auto-fix Common Issues
        if: inputs.fix_issues == true && (steps.health-check.outputs.health_status == 'failed' || steps.health-check.outputs.health_status == 'degraded')
        run: |
          echo "=== AUTO-FIX ATTEMPT ==="
          
          # Attempt to restart unhealthy tasks
          if [ "${{ steps.health-check.outputs.health_status }}" = "degraded" ]; then
            echo "üîÑ Attempting to restart unhealthy tasks..."
            
            # Force new deployment to restart tasks
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_SERVICE }} \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
              
            echo "‚úÖ Force deployment initiated"
            
            # Wait briefly for deployment to start
            sleep 30
            
            # Check if deployment is progressing
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].deployments[?status==`PRIMARY`] | [0].rolloutState' \
              --output text)
            
            echo "üîÑ New deployment status: $DEPLOYMENT_STATUS"
          fi
          
      - name: Generate Validation Report
        if: always()
        run: |
          echo "=== VALIDATION REPORT ==="
          
          REPORT_FILE="validation-report-${{ inputs.environment }}-$(date +%Y%m%d-%H%M%S).json"
          
          # Gather comprehensive status
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0]' --output json)
          
          CLUSTER_STATUS=$(aws ecs describe-clusters \
            --clusters ${{ env.ECS_CLUSTER }} \
            --region ${{ env.AWS_REGION }} \
            --query 'clusters[0]' --output json)
          
          # Create validation report
          cat > "$REPORT_FILE" << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "${{ inputs.environment }}",
            "validation_type": "${{ inputs.validation_type }}",
            "cluster": $CLUSTER_STATUS,
            "service": $SERVICE_STATUS,
            "validation_results": {
              "health_check_status": "${{ steps.health-check.outputs.health_status }}",
              "app_health_status": "${{ steps.app-health.outputs.app_health }}",
              "fix_attempted": "${{ inputs.fix_issues }}"
            },
            "recommendations": [
              "Review CloudWatch logs for detailed error information",
              "Check security groups and network configuration",
              "Verify task definition resource requirements",
              "Monitor application performance metrics"
            ]
          }
          EOF
          
          echo "üìÑ Validation report generated: $REPORT_FILE"
          cat "$REPORT_FILE" | jq .
          
      - name: Upload Validation Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-report-${{ inputs.environment }}-${{ github.run_id }}
          path: validation-report-*.json
          retention-days: 30
          
      - name: Notification
        if: always()
        continue-on-error: true
        run: |
          # Determine status and color
          if [ "${{ steps.health-check.outputs.health_status }}" = "healthy" ]; then
            STATUS_EMOJI="‚úÖ"
            STATUS_TEXT="Healthy"
            COLOR="3066993"
          elif [ "${{ steps.health-check.outputs.health_status }}" = "degraded" ]; then
            STATUS_EMOJI="‚ö†Ô∏è"
            STATUS_TEXT="Degraded"
            COLOR="16776960"
          else
            STATUS_EMOJI="‚ùå"
            STATUS_TEXT="Failed"
            COLOR="15158332"
          fi
          
          # Send Discord notification if webhook is configured
          if [ ! -z "${{ secrets.DISCORD_WEBHOOK }}" ]; then
            curl -H "Content-Type: application/json" \
              -X POST \
              -d "{
                \"embeds\": [{
                  \"title\": \"$STATUS_EMOJI Deployment Validation - ${{ inputs.environment }}\",
                  \"description\": \"Validation Type: ${{ inputs.validation_type }}\\nStatus: $STATUS_TEXT\",
                  \"color\": $COLOR,
                  \"fields\": [
                    {\"name\": \"Environment\", \"value\": \"${{ inputs.environment }}\", \"inline\": true},
                    {\"name\": \"Cluster\", \"value\": \"${{ env.ECS_CLUSTER }}\", \"inline\": true},
                    {\"name\": \"Service\", \"value\": \"${{ env.ECS_SERVICE }}\", \"inline\": true},
                    {\"name\": \"Health Status\", \"value\": \"${{ steps.health-check.outputs.health_status }}\", \"inline\": true},
                    {\"name\": \"App Health\", \"value\": \"${{ steps.app-health.outputs.app_health }}\", \"inline\": true},
                    {\"name\": \"Auto-fix Attempted\", \"value\": \"${{ inputs.fix_issues }}\", \"inline\": true}
                  ],
                  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
                }]
              }" \
              "${{ secrets.DISCORD_WEBHOOK }}" || echo "Discord notification failed"
          fi