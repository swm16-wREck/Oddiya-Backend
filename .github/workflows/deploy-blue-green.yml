name: Blue-Green Deploy to ECS

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  actions: read
  checks: write
  pull-requests: write
  security-events: write
  id-token: write

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: oddiya

jobs:
  # Pre-deployment validation
  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should-deploy: ${{ steps.validation.outputs.should-deploy }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Determine environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="prod"
          else
            ENV="dev"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "üéØ Target environment: $ENV"

      - name: Validate deployment readiness
        id: validation
        run: |
          # Check if this is a valid deployment
          if [[ "${{ github.event.inputs.skip_tests }}" == "true" ]]; then
            echo "‚ö†Ô∏è Tests will be skipped - manual override"
          fi
          
          # Check for deployment markers
          if git log --oneline -1 | grep -qiE '\[skip deploy\]|\[no deploy\]'; then
            echo "‚ùå Deployment skipped due to commit message marker"
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Deployment validation passed"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          fi

  # Run comprehensive tests (unless skipped)
  test-suite:
    name: Comprehensive Test Suite
    needs: validate-deployment
    if: needs.validate-deployment.outputs.should-deploy == 'true' && github.event.inputs.skip_tests != 'true'
    uses: ./.github/workflows/ci-pipeline.yml
    secrets: inherit

  # Build and prepare deployment
  build-and-prepare:
    name: Build & Prepare
    needs: [validate-deployment, test-suite]
    if: always() && needs.validate-deployment.outputs.should-deploy == 'true' && (needs.test-suite.result == 'success' || github.event.inputs.skip_tests == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-uri: ${{ steps.build.outputs.image-uri }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: gradle

      - name: Build application
        run: |
          chmod +x gradlew
          ./gradlew clean build -x test
          echo "‚úÖ Application build completed"

      - name: Build and push Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ needs.validate-deployment.outputs.environment }}
        run: |
          # Build image with multiple tags
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          docker build -t $IMAGE_URI \
            --build-arg SPRING_PROFILES_ACTIVE=$ENVIRONMENT \
            --build-arg BUILD_VERSION=$IMAGE_TAG \
            --label "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .
          
          # Push with commit SHA tag
          docker push $IMAGE_URI
          
          # Also tag and push with environment-specific tags
          docker tag $IMAGE_URI "$ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT-latest"
          docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT-latest"
          
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "‚úÖ Docker image built and pushed: $IMAGE_URI"

  # Blue-Green Deployment
  deploy-blue-green:
    name: Blue-Green Deployment
    needs: [validate-deployment, build-and-prepare]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: 
      name: ${{ needs.validate-deployment.outputs.environment }}
      url: https://${{ needs.validate-deployment.outputs.environment == 'prod' && 'api.oddiya.com' || format('{0}-api.oddiya.com', needs.validate-deployment.outputs.environment) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set deployment variables
        id: vars
        env:
          ENVIRONMENT: ${{ needs.validate-deployment.outputs.environment }}
        run: |
          echo "cluster=oddiya-${ENVIRONMENT}-cluster" >> $GITHUB_OUTPUT
          echo "service=oddiya-${ENVIRONMENT}-app" >> $GITHUB_OUTPUT
          echo "task-family=oddiya-${ENVIRONMENT}-app" >> $GITHUB_OUTPUT

      - name: Download current task definition
        id: current-task-def
        run: |
          # Try to download existing task definition, or create new one
          if aws ecs describe-task-definition \
            --task-definition ${{ steps.vars.outputs.task-family }} \
            --query taskDefinition > current-task-definition.json 2>/dev/null; then
            echo "‚úÖ Current task definition downloaded"
          else
            echo "‚ö†Ô∏è Task definition not found, creating new one"
            
            # Create task definition JSON using jq for proper JSON formatting
            echo '{}' | jq \
              --arg family "${{ steps.vars.outputs.task-family }}" \
              --arg image "placeholder" \
              --arg dbhost "${{ secrets.PROD_DATABASE_HOST || 'oddiya-db.c5qzkoxebfro.ap-northeast-2.rds.amazonaws.com' }}" \
              --arg dbuser "${{ secrets.PROD_DATABASE_USERNAME || 'oddiya_user' }}" \
              --arg dbpass "${{ secrets.PROD_DATABASE_PASSWORD }}" \
              --arg region "${{ env.AWS_REGION }}" \
              --arg logsgroup "/ecs/${{ steps.vars.outputs.task-family }}" \
              '.family = $family |
              .networkMode = "awsvpc" |
              .requiresCompatibilities = ["FARGATE"] |
              .cpu = "512" |
              .memory = "1024" |
              .taskRoleArn = "arn:aws:iam::501544476367:role/ecsTaskExecutionRole" |
              .executionRoleArn = "arn:aws:iam::501544476367:role/ecsTaskExecutionRole" |
              .containerDefinitions = [{
                name: "oddiya-app",
                image: $image,
                essential: true,
                portMappings: [{
                  containerPort: 8080,
                  protocol: "tcp"
                }],
                environment: [
                  {name: "SPRING_PROFILES_ACTIVE", value: "postgresql,production"},
                  {name: "DATABASE_HOST", value: $dbhost},
                  {name: "DATABASE_PORT", value: "5432"},
                  {name: "DATABASE_NAME", value: "oddiya"},
                  {name: "DATABASE_USERNAME", value: $dbuser},
                  {name: "DATABASE_PASSWORD", value: $dbpass},
                  {name: "SPRING_DATASOURCE_URL", value: ("jdbc:postgresql://" + $dbhost + ":5432/oddiya")}
                ],
                logConfiguration: {
                  logDriver: "awslogs",
                  options: {
                    "awslogs-group": $logsgroup,
                    "awslogs-region": $region,
                    "awslogs-stream-prefix": "ecs",
                    "awslogs-create-group": "true"
                  }
                }
              }]' > current-task-definition.json
            
            echo "‚úÖ New task definition created"
          fi

      - name: Create new task definition
        id: new-task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: current-task-definition.json
          container-name: oddiya-app
          image: ${{ needs.build-and-prepare.outputs.image-uri }}

      - name: Ensure ECS infrastructure exists
        id: ensure-infrastructure
        run: |
          echo "üèóÔ∏è Checking and creating ECS infrastructure..."
          
          # Check if cluster exists, create if not
          if ! aws ecs describe-clusters --clusters ${{ steps.vars.outputs.cluster }} --query 'clusters[0].clusterName' --output text | grep -q ${{ steps.vars.outputs.cluster }}; then
            echo "‚öôÔ∏è Creating ECS cluster: ${{ steps.vars.outputs.cluster }}"
            aws ecs create-cluster --cluster-name ${{ steps.vars.outputs.cluster }}
            echo "‚úÖ ECS cluster created"
          else
            echo "‚úÖ ECS cluster already exists: ${{ steps.vars.outputs.cluster }}"
          fi
          
          # Check if service exists, create if not
          if ! aws ecs describe-services --cluster ${{ steps.vars.outputs.cluster }} --services ${{ steps.vars.outputs.service }} --query 'services[0].serviceName' --output text 2>/dev/null | grep -q ${{ steps.vars.outputs.service }}; then
            echo "‚öôÔ∏è Creating ECS service: ${{ steps.vars.outputs.service }}"
            
            # Create default VPC config (using default VPC and subnets)
            DEFAULT_VPC=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text)
            
            # Get public subnets only (for internet access)
            SUBNETS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$DEFAULT_VPC" "Name=map-public-ip-on-launch,Values=true" \
              --query 'Subnets[:2].SubnetId' \
              --output text | tr '\t' ',')
            
            # If no public subnets, fall back to any subnets
            if [ -z "$SUBNETS" ]; then
              SUBNETS=$(aws ec2 describe-subnets \
                --filters "Name=vpc-id,Values=$DEFAULT_VPC" \
                --query 'Subnets[:2].SubnetId' \
                --output text | tr '\t' ',')
            fi
            
            # Get or create security group for ECS
            SECURITY_GROUP=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$DEFAULT_VPC" "Name=group-name,Values=oddiya-ecs-sg" \
              --query 'SecurityGroups[0].GroupId' \
              --output text 2>/dev/null || echo "")
            
            if [ -z "$SECURITY_GROUP" ] || [ "$SECURITY_GROUP" = "None" ]; then
              echo "Creating security group for ECS..."
              SECURITY_GROUP=$(aws ec2 create-security-group \
                --group-name oddiya-ecs-sg \
                --description "Security group for Oddiya ECS tasks" \
                --vpc-id "$DEFAULT_VPC" \
                --query 'GroupId' \
                --output text)
              
              # Allow all outbound traffic (for pulling images and accessing services)
              aws ec2 authorize-security-group-egress \
                --group-id "$SECURITY_GROUP" \
                --protocol all \
                --cidr 0.0.0.0/0 || true
              
              # Allow inbound HTTP traffic
              aws ec2 authorize-security-group-ingress \
                --group-id "$SECURITY_GROUP" \
                --protocol tcp \
                --port 8080 \
                --cidr 0.0.0.0/0 || true
            fi
            
            # First register the task definition to get the ARN
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://${{ steps.new-task-def.outputs.task-definition }} \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
              
            # Create service
            aws ecs create-service \
              --cluster ${{ steps.vars.outputs.cluster }} \
              --service-name ${{ steps.vars.outputs.service }} \
              --task-definition $NEW_TASK_DEF_ARN \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
              --enable-execute-command
            
            echo "‚úÖ ECS service created"
            echo "‚è≥ Waiting for initial service to stabilize..."
            sleep 30
          else
            echo "‚úÖ ECS service already exists: ${{ steps.vars.outputs.service }}"
          fi

      - name: Deploy to ECS (Blue-Green)
        id: deploy
        run: |
          # Register new task definition
          echo "üìù Registering new task definition..."
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://${{ steps.new-task-def.outputs.task-definition }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "new-task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "‚úÖ New task definition registered: $NEW_TASK_DEF_ARN"
          
          # Get current service info
          echo "üìä Getting current service state..."
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ steps.vars.outputs.cluster }} \
            --services ${{ steps.vars.outputs.service }} \
            --query 'services[0].taskDefinition' \
            --output text)
          
          DESIRED_COUNT=$(aws ecs describe-services \
            --cluster ${{ steps.vars.outputs.cluster }} \
            --services ${{ steps.vars.outputs.service }} \
            --query 'services[0].desiredCount' \
            --output text)
          
          echo "current-task-def=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
          echo "desired-count=$DESIRED_COUNT" >> $GITHUB_OUTPUT
          
          echo "Current task definition: $CURRENT_TASK_DEF"
          echo "Current desired count: $DESIRED_COUNT"
          
          # Update service with new task definition
          echo "üîÑ Starting blue-green deployment..."
          aws ecs update-service \
            --cluster ${{ steps.vars.outputs.cluster }} \
            --service ${{ steps.vars.outputs.service }} \
            --task-definition $NEW_TASK_DEF_ARN \
            --force-new-deployment \
            > /dev/null
          
          echo "‚úÖ Service update initiated"

      - name: Wait for deployment to complete
        run: |
          echo "‚è≥ Waiting for deployment to stabilize..."
          echo "This may take several minutes as tasks start and pass health checks..."
          
          # Monitor deployment with detailed logging
          TIMEOUT=1200  # 20 minutes
          ELAPSED=0
          INTERVAL=30
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Get service status
            SERVICE_STATUS=$(aws ecs describe-services \
              --cluster ${{ steps.vars.outputs.cluster }} \
              --services ${{ steps.vars.outputs.service }} \
              --query 'services[0].{deployments:deployments,runningCount:runningCount,pendingCount:pendingCount,desiredCount:desiredCount}' \
              --output json)
            
            DEPLOYMENT_STATUS=$(echo "$SERVICE_STATUS" | jq -r '.deployments[] | select(.status=="PRIMARY") | .rolloutState // "PENDING"')
            RUNNING_COUNT=$(echo "$SERVICE_STATUS" | jq -r '.runningCount // 0')
            PENDING_COUNT=$(echo "$SERVICE_STATUS" | jq -r '.pendingCount // 0')
            DESIRED_COUNT=$(echo "$SERVICE_STATUS" | jq -r '.desiredCount // 1')
            
            echo "üîÑ Deployment status: $DEPLOYMENT_STATUS | Tasks: $RUNNING_COUNT/$DESIRED_COUNT running, $PENDING_COUNT pending | Elapsed: ${ELAPSED}s"
            
            # Check deployment status
            if [ "$DEPLOYMENT_STATUS" = "COMPLETED" ] && [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ] && [ "$PENDING_COUNT" = "0" ]; then
              echo "‚úÖ Deployment completed successfully!"
              break
            elif [ "$DEPLOYMENT_STATUS" = "FAILED" ]; then
              echo "‚ùå Deployment failed!"
              echo "üìã Recent service events:"
              aws ecs describe-services \
                --cluster ${{ steps.vars.outputs.cluster }} \
                --services ${{ steps.vars.outputs.service }} \
                --query 'services[0].events[:5].[createdAt,message]' \
                --output table
              exit 1
            fi
            
            # Check for stopped tasks (potential failures)
            STOPPED_TASKS=$(aws ecs list-tasks \
              --cluster ${{ steps.vars.outputs.cluster }} \
              --service-name ${{ steps.vars.outputs.service }} \
              --desired-status STOPPED \
              --query 'length(taskArns)')
            
            if [ "$STOPPED_TASKS" -gt 0 ]; then
              echo "‚ö†Ô∏è Found $STOPPED_TASKS stopped tasks, checking reasons..."
              
              # Get stopped tasks differently - without pagination
              RECENT_STOPPED_TASKS=$(aws ecs list-tasks \
                --cluster ${{ steps.vars.outputs.cluster }} \
                --service-name ${{ steps.vars.outputs.service }} \
                --desired-status STOPPED \
                --query 'taskArns[:3]' \
                --output json | jq -r '.[]' 2>/dev/null || echo "")
              
              if [ ! -z "$RECENT_STOPPED_TASKS" ] && [ "$RECENT_STOPPED_TASKS" != "None" ]; then
                echo "üìã Most recent stopped task details:"
                echo "$RECENT_STOPPED_TASKS" | while read task_arn; do
                  if [ ! -z "$task_arn" ] && [ "$task_arn" != "None" ]; then
                    echo "Checking task: $task_arn"
                    aws ecs describe-tasks \
                      --cluster ${{ steps.vars.outputs.cluster }} \
                      --tasks "$task_arn" \
                      --query 'tasks[0].{StoppedReason:stoppedReason,LastStatus:lastStatus,StoppedAt:stoppedAt,Containers:containers[].{Name:name,ExitCode:exitCode,Reason:reason}}' \
                      --output json | jq . || true
                    echo "---"
                  fi
                done
              else
                echo "Could not retrieve stopped task details"
                # Try to get service events instead
                echo "üìã Recent service events:"
                aws ecs describe-services \
                  --cluster ${{ steps.vars.outputs.cluster }} \
                  --services ${{ steps.vars.outputs.service }} \
                  --query 'services[0].events[:5]' \
                  --output json | jq -r '.[] | "\(.createdAt): \(.message)"' || true
              fi
              
              # Check if log group exists and create if needed
              LOG_GROUP="/ecs/${{ steps.vars.outputs.task-family }}"
              if ! aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[?logGroupName==`'"$LOG_GROUP"'`]' --output text | grep -q "$LOG_GROUP"; then
                echo "Creating CloudWatch log group: $LOG_GROUP"
                aws logs create-log-group --log-group-name "$LOG_GROUP" || true
              fi
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚è∞ Deployment timed out after $TIMEOUT seconds"
            echo "üìã Final service state:"
            aws ecs describe-services \
              --cluster ${{ steps.vars.outputs.cluster }} \
              --services ${{ steps.vars.outputs.service }} \
              --query 'services[0].{Status:status,RunningCount:runningCount,PendingCount:pendingCount,DesiredCount:desiredCount,Deployments:deployments[].{Status:status,RolloutState:rolloutState,CreatedAt:createdAt}}' \
              --output json | jq .
            exit 1
          fi

      - name: Verify deployment health
        id: health-check
        run: |
          echo "üè• Performing post-deployment health checks..."
          
          # Get service status
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster ${{ steps.vars.outputs.cluster }} \
            --services ${{ steps.vars.outputs.service }} \
            --query 'services[0].runningCount' \
            --output text)
          
          DESIRED_COUNT=$(aws ecs describe-services \
            --cluster ${{ steps.vars.outputs.cluster }} \
            --services ${{ steps.vars.outputs.service }} \
            --query 'services[0].desiredCount' \
            --output text)
          
          PENDING_COUNT=$(aws ecs describe-services \
            --cluster ${{ steps.vars.outputs.cluster }} \
            --services ${{ steps.vars.outputs.service }} \
            --query 'services[0].pendingCount' \
            --output text)
          
          echo "Service Status:"
          echo "  Running: $RUNNING_COUNT"
          echo "  Desired: $DESIRED_COUNT" 
          echo "  Pending: $PENDING_COUNT"
          
          if [[ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" && "$PENDING_COUNT" -eq "0" ]]; then
            echo "‚úÖ Service is healthy: $RUNNING_COUNT/$DESIRED_COUNT tasks running"
            echo "health-status=healthy" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Service may be unhealthy: $RUNNING_COUNT/$DESIRED_COUNT tasks running, $PENDING_COUNT pending"
            echo "health-status=unhealthy" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Run smoke tests
        id: smoke-tests
        env:
          ENVIRONMENT: ${{ needs.validate-deployment.outputs.environment }}
        run: |
          echo "üß™ Running smoke tests..."
          
          # Determine the correct endpoint
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            ENDPOINT="https://api.oddiya.com"
          else
            ENDPOINT="https://${ENVIRONMENT}-api.oddiya.com"
          fi
          
          echo "Testing endpoint: $ENDPOINT"
          
          # Health check
          if curl -f -s --max-time 30 "$ENDPOINT/actuator/health" > /dev/null; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi
          
          # Additional smoke tests can be added here
          echo "‚úÖ All smoke tests passed"

      - name: Cleanup old task definitions
        if: steps.health-check.outputs.health-status == 'healthy'
        run: |
          echo "üßπ Cleaning up old task definitions..."
          
          # Keep last 5 task definition revisions
          aws ecs list-task-definitions \
            --family-prefix ${{ steps.vars.outputs.task-family }} \
            --sort DESC \
            --query 'taskDefinitionArns[5:]' \
            --output text | tr '\t' '\n' | while read -r task_def_arn; do
            if [[ -n "$task_def_arn" ]]; then
              echo "Deregistering old task definition: $task_def_arn"
              aws ecs deregister-task-definition --task-definition "$task_def_arn" > /dev/null || true
            fi
          done
          
          echo "‚úÖ Old task definitions cleaned up"

  # Rollback capability
  rollback:
    name: Rollback Deployment
    needs: [validate-deployment, deploy-blue-green]
    if: failure() && needs.deploy-blue-green.steps.deploy.outputs.current-task-def != ''
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback to previous task definition
        env:
          CLUSTER: oddiya-${{ needs.validate-deployment.outputs.environment }}-cluster
          SERVICE: oddiya-${{ needs.validate-deployment.outputs.environment }}-app
        run: |
          echo "üîÑ Rolling back to previous task definition..."
          
          PREVIOUS_TASK_DEF="${{ needs.deploy-blue-green.steps.deploy.outputs.current-task-def }}"
          
          aws ecs update-service \
            --cluster $CLUSTER \
            --service $SERVICE \
            --task-definition $PREVIOUS_TASK_DEF \
            --force-new-deployment \
            > /dev/null
          
          echo "‚è≥ Waiting for rollback to complete..."
          aws ecs wait services-stable \
            --cluster $CLUSTER \
            --services $SERVICE
          
          echo "‚úÖ Rollback completed successfully"

  # Post-deployment notifications
  notify:
    name: Deployment Notifications
    needs: [validate-deployment, deploy-blue-green]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment Success Notification
        if: needs.deploy-blue-green.result == 'success'
        run: |
          echo "üéâ Deployment Successful!"
          echo ""
          echo "Environment: ${{ needs.validate-deployment.outputs.environment }}"
          echo "Image: ${{ needs.build-and-prepare.outputs.image-uri }}"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Application is now live and serving traffic."

      - name: Deployment Failure Notification
        if: needs.deploy-blue-green.result == 'failure'
        run: |
          echo "‚ùå Deployment Failed!"
          echo ""
          echo "Environment: ${{ needs.validate-deployment.outputs.environment }}"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Check the logs above for details. Rollback may have been attempted."
          exit 1