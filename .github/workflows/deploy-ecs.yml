name: Deploy to Amazon ECS

on:
  push:
    branches: [main, develop]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  actions: read
  checks: write

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: oddiya
  ECS_SERVICE: oddiya-dev
  ECS_CLUSTER: oddiya-dev
  ECS_TASK_DEFINITION: oddiya-dev
  CONTAINER_NAME: oddiya

jobs:
  # Pre-deployment checks
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should-migrate: ${{ steps.check-migrations.outputs.should-migrate }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Set environment
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
      
      - name: Check database connectivity
        run: |
          # Install PostgreSQL client
          sudo apt-get update
          sudo apt-get install -y postgresql-client jq
          
          # Test database connection
          ENVIRONMENT=${{ steps.set-env.outputs.environment }}
          echo "Testing database connectivity for environment: $ENVIRONMENT"
          
          # This would normally test actual connectivity
          # For now, we'll just validate the environment is set
          if [[ -z "$ENVIRONMENT" ]]; then
            echo "âŒ Environment not set correctly"
            exit 1
          fi
          
          echo "âœ… Pre-deployment checks passed for environment: $ENVIRONMENT"
      
      - name: Check for pending migrations
        id: check-migrations
        run: |
          # Count migration files
          MIGRATION_COUNT=$(find src/main/resources/db/migration -name "V*.sql" -type f | wc -l || echo "0")
          
          if [[ $MIGRATION_COUNT -gt 0 ]]; then
            echo "should-migrate=true" >> $GITHUB_OUTPUT
            echo "Found $MIGRATION_COUNT migration files"
          else
            echo "should-migrate=false" >> $GITHUB_OUTPUT
            echo "No migration files found"
          fi

  # Database migration job (runs before deployment)
  migrate-database:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    timeout-minutes: 20
    if: needs.pre-deployment-checks.outputs.should-migrate == 'true'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: gradle
      
      - name: Install database tools
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client jq
      
      # Skip database migrations - using JPA DDL auto-update instead
      # Uncomment below if you want to use Flyway migrations with AWS Secrets Manager
      # - name: Run database migrations
      #   run: |
      #     chmod +x scripts/deployment/migrate-database.sh
      #     ./scripts/deployment/migrate-database.sh ${{ needs.pre-deployment-checks.outputs.environment }}
      #   env:
      #     SNS_TOPIC_ARN: ${{ secrets.SNS_TOPIC_ARN }}
      
      # Migration logs upload skipped since we're using JPA DDL auto-update

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, migrate-database]
    timeout-minutes: 30
    if: always() && (needs.pre-deployment-checks.result == 'success') && (needs.migrate-database.result == 'success' || needs.migrate-database.result == 'skipped')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Build application
        run: |
          chmod +x gradlew
          # Clean everything including Gradle cache
          rm -rf build/ .gradle/
          ./gradlew clean bootJar --no-daemon --no-build-cache -x test -x compileTestJava -x checkstyleTest

      - name: Build and push Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Force complete rebuild with no cache and fresh base image
          docker build --no-cache --pull --build-arg CACHEBUST=$(date +%s) -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Prepare task definition
        run: |
          # Try to download existing task definition, or use local one
          if aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --query taskDefinition > task-definition.json 2>/dev/null; then
            echo "Using existing task definition from AWS"
          else
            echo "Task definition not found in AWS, using local file"
            if [ -f ecs-task-definition.json ]; then
              cp ecs-task-definition.json task-definition.json
            else
              echo "Creating new task definition"
              cat > task-definition.json << 'EOF'
{
  "family": "${{ env.ECS_TASK_DEFINITION }}",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID || '501544476367' }}:role/ecsTaskExecutionRole",
  "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID || '501544476367' }}:role/ecsTaskExecutionRole",
  "containerDefinitions": [
    {
      "name": "${{ env.CONTAINER_NAME }}",
      "image": "placeholder",
      "essential": true,
      "portMappings": [
        {
          "containerPort": 8080,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "SPRING_PROFILES_ACTIVE",
          "value": "postgresql,production"
        },
        {
          "name": "DATABASE_HOST",
          "value": "oddiya-db.c5qzkoxebfro.ap-northeast-2.rds.amazonaws.com"
        },
        {
          "name": "DATABASE_PORT",
          "value": "5432"
        },
        {
          "name": "DATABASE_NAME",
          "value": "oddiya"
        },
        {
          "name": "DATABASE_USERNAME",
          "value": "oddiya_user"
        },
        {
          "name": "DATABASE_PASSWORD",
          "value": "dnjswltnduftpdls"
        },
        {
          "name": "SPRING_DATASOURCE_URL",
          "value": "jdbc:postgresql://oddiya-db.c5qzkoxebfro.ap-northeast-2.rds.amazonaws.com:5432/oddiya"
        },
        {
          "name": "SPRING_DATASOURCE_USERNAME",
          "value": "oddiya_user"
        },
        {
          "name": "SPRING_DATASOURCE_PASSWORD",
          "value": "dnjswltnduftpdls"
        },
        {
          "name": "JAVA_TOOL_OPTIONS",
          "value": "-Xmx768m -Xms256m"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/${{ env.ECS_TASK_DEFINITION }}",
          "awslogs-region": "${{ env.AWS_REGION }}",
          "awslogs-stream-prefix": "ecs",
          "awslogs-create-group": "true"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 60
      }
    }
  ]
}
EOF
            fi
          fi

      - name: Update task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy to ECS
        run: |
          # Register new task definition
          TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://${{ steps.task-def.outputs.task-definition }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          # Update service
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition $TASK_ARN \
            --output json > /dev/null
          
          # Wait for deployment to complete
          echo "â³ Waiting for deployment to complete..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} || {
              echo "âŒ Deployment failed or timed out"
              exit 1
          }
          
          echo "âœ… Deployment completed successfully!"

      - name: Verify deployment
        run: |
          RUNNING=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].runningCount' \
            --output text)
          
          DESIRED=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].desiredCount' \
            --output text)
          
          if [ "$RUNNING" -eq "$DESIRED" ]; then
            echo "âœ… ECS Service is healthy: $RUNNING/$DESIRED tasks running"
          else
            echo "âš ï¸ ECS Service may be unhealthy: $RUNNING/$DESIRED tasks running"
            exit 1
          fi
      
      - name: Verify PostgreSQL connectivity from application
        run: |
          # Get application load balancer URL
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, 'oddiya')].DNSName | [0]" \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$ALB_DNS" ] || [ "$ALB_DNS" = "None" ]; then
            echo "No load balancer found, skipping health check"
            exit 0
          fi
          
          APP_URL="http://${ALB_DNS}"
          echo "Testing application health at: $APP_URL"
          
          # Wait for application to be ready (up to 5 minutes)
          for i in {1..30}; do
            if curl -f -s --connect-timeout 10 "${APP_URL}/actuator/health/readiness" >/dev/null 2>&1; then
              echo "âœ… Application readiness check passed"
              break
            elif [[ $i -eq 30 ]]; then
              echo "âŒ Application readiness check failed after 5 minutes"
              exit 1
            else
              echo "â³ Waiting for application readiness... (attempt $i/30)"
              sleep 10
            fi
          done
          
          # Test database connectivity through application
          if curl -f -s --connect-timeout 10 "${APP_URL}/actuator/health/db" >/dev/null 2>&1; then
            echo "âœ… Database connectivity check passed through application"
          else
            echo "âš ï¸ Database connectivity check failed through application"
            # Don't fail deployment but warn
          fi
          
          # Test specific health indicators
          HEALTH_RESPONSE=$(curl -s "${APP_URL}/actuator/health" 2>/dev/null || echo '{"status":"UNKNOWN"}')
          HEALTH_STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.status // "UNKNOWN"')
          
          echo "Application health status: $HEALTH_STATUS"
          if [[ "$HEALTH_STATUS" == "UP" ]]; then
            echo "âœ… Application is fully healthy"
          else
            echo "âš ï¸ Application health status is not UP: $HEALTH_STATUS"
          fi
          
      - name: Run post-deployment health check
        run: |
          # Install PostgreSQL client for direct database checks
          sudo apt-get update
          sudo apt-get install -y postgresql-client jq
          
          # Run comprehensive health check if script exists
          if [ -f scripts/monitoring/postgresql-health-check.sh ]; then
            chmod +x scripts/monitoring/postgresql-health-check.sh
            ./scripts/monitoring/postgresql-health-check.sh ${{ needs.pre-deployment-checks.outputs.environment }} || echo "Health check script failed, continuing"
          else
            echo "Health check script not found, skipping"
          fi
        env:
          SNS_TOPIC_ARN: ${{ secrets.SNS_TOPIC_ARN }}
      
      - name: Upload health check logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-check-logs-${{ needs.pre-deployment-checks.outputs.environment }}
          path: /tmp/postgresql-health-*.log
          retention-days: 7
          if-no-files-found: ignore
      
      - name: Post deployment summary
        if: always()
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.pre-deployment-checks.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ steps.build-image.outputs.image }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. âœ… Pre-deployment checks" >> $GITHUB_STEP_SUMMARY
          echo "2. ${{ needs.migrate-database.result == 'success' && 'âœ…' || needs.migrate-database.result == 'skipped' && 'â¸ï¸' || 'âŒ' }} Database migrations" >> $GITHUB_STEP_SUMMARY
          echo "3. âœ… Application build and deploy" >> $GITHUB_STEP_SUMMARY
          echo "4. âœ… PostgreSQL health checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ðŸŽ‰ Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY